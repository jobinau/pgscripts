global_defs {
    process_names

    enable_script_security  # Check that the script can only be edited by root

    script_user root        # Systemctl does only work with root

    vrrp_version 3          # Using the latest protocol version allows for dynamic_interfaces

    # vrrp_min_garp true      # After switching to MASTER state 5 gratuitous arp (garp) are send and
                            # after 5 seconds another 5 garp are send. (For the switches to update the arp table)
                            # This option disables the second time "5 garp are send (as this is not necessary with modern switches)
}

vrrp_script chk_patroni {
    script "/usr/local/bin/chk_primary.sh"

    # script "/usr/bin/killall -0 haproxy"     # Sending the zero signal returns OK (0) if the process or process group ID exists, 
                                    # otherwise, it returns ERR (-1 and sets errno to ESRCH). 
                                    # Note that the kill(2) man page states that error checking is still performed, 
                                    # meaning it will return na error (-1) and set errno to EPERM if: 
                                    #   - The target process doesn't exists 
                                    #   - The target process exists but the sending process does not have enough permissions to send it a signal

    # script "/usr/bin/systemctl is-active --quiet haproxy"   # The more intelligent way of checking the haproxy process
                                    # Simpler way of checking haproxy process:
                                    # script "/usr/bin/killall -0 haproxy"

    fall 2                          # 2 fails required for failure

    rise 2                          # 2 OKs required to consider the process up after failure

    interval 1                     # check every X seconds

    weight -10                     # add 10 points rc=0
}

vrrp_instance CLUSTER_1 {
    state MASTER            # Initial state, MASTER|BACKUP
                            # MASTER on haproxy1, BACKUP on haproxy2, BACKUP on haproxy3, etc
                            # NOTE that if the priority is 255, then the instance will transition immediately
                            # to MASTER if state MASTER is specified; otherwise the instance will
                            # wait between 3 and 4 advert intervals before it can transition,
                            # depending on the priority

    interface enp1s0        # interface for inside_network, bound by vrrp.
                            # Note: if using unicasting, the interface can be omitted as long
                            #   as the unicast addresses are not IPv6 link local addresses (this is
                            #   necessary, for example, if using asymmetric routing).
                            #   If the interface is omitted, then all VIPs and eVIPs should specify
                            #   the interface they are to be configured on, otherwise they will be
                            #   added to the default interface.

    virtual_router_id 99    # Needs to be the same value in all nodes of the same cluster
                            # HOWEVER, each cluster needs to have an UNIQUE ID

    priority 100            # The higher the priority the higher the chance to be promoted to MASTER
    advert_int 1            # Specify the VRRP Advert interval in seconds

    # authentication {        # Non compliant but good to have with unicast
    #     auth_type PASS
    #     auth_pass passw123
    # }

    unicast_src_ip 192.168.124.158  # The default IP for binding vrrpd is the primary IP
                                    # on the defined interface. If you want to hide the location of vrrpd,
                                    # use this IP as src_addr for multicast or unicast vrrp packets.

    unicast_peer {                  # Do not send VRRP adverts over a VRRP multicast group.
                                    # Instead it sends adverts to the following list of
                                    # ip addresses using unicast. It can be cool to use
                                    # the VRRP FSM and features in a networking
                                    # environment where multicast is not supported!
                                    # IP addresses specified can be IPv4 as well as IPv6.
                                    # If min_ttl and/or max_ttl are specified, the TTL/hop limit
                                    # of any received packet is checked against the specified
                                    # TTL range, and is discarded if it is outside the range.
                                    # Specifying min_ttl or max_ttl turns on check_unicast_src.
        192.168.124.121
        192.168.124.129
    }

    unicast_fault_no_peer           # It is not possible to operate in unicast mode without any peers.
                                    # Until v2.2.4 keepalived would silently operate in multicast mode
                                    # if no peers were specified but a unicast keyword had been specified.
                                    # Using this keywork stops defaulting to multicast if no peers are
                                    # specified and puts the VRRP instance into fault state.

    virtual_ipaddress {
        192.168.124.99/24 brd + dev enp1s0 label enp1s0:0
    }

    track_script {          # Check that haproxy is up
        chk_patroni
    }
}

